---
layout: post
title: 2021-11-16-TIL
subtitle: "libft 내장함수 공부하기"
categories: 42seoul
tags:
- 42
- TIL
comments: true
published: true
---

# libft(1)

## 내장함수들의 기능정리

###is 함수들 -> unsigned char 또는 EOF 인 c에 대해서 문자의 class를 표시한다. 

isalpha  
`int isalpha(int c);`  
알파벳 대문자일 경우에 1을 반환하고, 소문자는 2, 이외에는 0을 반환한다.  


isdigit  
`int isdigit(int c);`  
0~9 사이의숫자가 아닐경우 0을 반환한다.  


isalnum  
`int isalnum(int c);`  
(isalpha(c) || isdigit(c)) 와 동일하게 동작한다.  


isascii  
`int isascii(int c);`  
7비트 US-ASCII 문자 세트로 표시될 수 없으면 0을 리턴한다.(0~127)  



### string 관련 함수들


strlen  
`size_t	ft_strlen(const char *s)`
문자열의 길이를 반환하는 함수이다.  


strlcpy
`size_t strlcpy(char * dest, const char * src, size_t size)`  
문자열을 복사하는 함수이다. dest 에 src 를 복사해주지만 size - 1 개 만큼의 문자들을 복사 한 뒤 , 끝에 '\0'을 붙여준다.  
반환값은 src의 길이이다. (NULL 값은 제외한다.)  
사용 가능한 메모리 영역을 넘어설 때 발생하는 오류인 overflow를 이용한 해킹 공격을 방어하기 위해 만들어졌다.  
스택에 정해진 버퍼보다 큰 공격 코드를 삽입하여 공격하는 스택 버퍼 오버플로우 공격을 size_t 에서 길이를 검사하므로 방어 할 수 있다.  

strlcat  
`size_t strlcat(char *dst, const char *src, size_t len)`  
strcat에서 일어날 수 있는 overflow를 이용한 공격을 방어하기 위해 만들었는데
추가할 문자의 개수만 정하는 strncat(dest 버퍼보다 커져서 overflow를 유발함)과는 달리 이어붙인 문자열의 총 길이를 통제할 수 있다.




### memory 관련 함수들  


memset  
`void	*ft_memset(void *s, int c, size_t n)`  
메모리의 시작 주소 s 로부터  n의 길이만큼 값 c로 세팅할 수 있음 한 바이트를 초기화 하는것이기 때문에 int 형으로 받은뒤에 내부적으로 unsigned char로 변환해서 저장한다.  
free()한 주소의 데이터들은 없어지지 않고 남아 있으므로 다음에 할당되었을때 이전 데이터가 그대로 저장 될 수 있기 때문에 초기화 해주는것이 좋음  
반환값은 시작 주소 s  

bzero  
`void	ft_bzero(void *s, size_t n)`  
메모리의 시작 주소 s 로부터 n의 길이만큼 0으로 세팅한다.  
calloc 을 구현할때 사용 할 수 있음.  


memcpy
`void	*ft_memcpy(void *dest, const void *src, size_t n)`  
복사 받을 메모리 dest 에 src 의 데이터를 n 길이만큼 복사 붙여넣기를 해주는 함수이다.  
반환값은 복사된 주소 dest  


memmove  
`void	*ft_memmove(void *dest, const void *src, size_t num)`  
memcpy 에서 dest 와 src 의 공간이 겹쳐졌을때 나타나는 메모리 중복 현상을 해결하기 위해서 쓰는 함수이다.  
버퍼를 사용해서 임시로 저장하고 그 값을 붙여넣는 형식으로 구현한다. libft 과제에서는 dest 와 src의 시작주소의 위치를 비교하여  
앞에서 부터 시작하거나 뒤에서부터 시작하는 방식으로 구현을 했다.  

